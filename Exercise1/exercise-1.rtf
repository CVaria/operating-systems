{\rtf1\ansi\ansicpg1252\deff0\nouicompat\deflang1033{\fonttbl{\f0\fnil\fcharset0 Times New Roman;}}
{\colortbl ;\red0\green0\blue255;}
{\*\generator Riched20 10.0.17134}\viewkind4\uc1 
\pard\sa200\sl276\slmult1\qj\b\f0\fs24\lang9 COMPUTER SYSTEMS LABORATORY\par
 \par
Exercise 1 Monitoring application resource usage with Linux Cgroups\par
 \par
Introduction\par
\b0 A data center offers market-based application hosting services. On the one hand, the data center wants to exploit its entire infrastructure without idle resources. On the other hand, its clients demand the resources they have ordered to be made available reliably. If the data center is overloaded with applications then it will not be able to meet the requirements of all applications.\par
For this exercise we assume that the requirement of an application is measured in milliseconds of the computing power of a processor. A node with 16 processors can cover a total of 16000mm and thus can serve, for example, 8 applications that require a 2000mm warranty each.\par
However, if these 8 applications are inelastic and do not consistently consume the entire 2000 millimeters provided for them, then the node remains idle. To avoid this we could put only 7 2000mm inelastic applications and 10 200mm elastic applications. The 10 resilient applications will only exploit processors when 7 is not in use.\par
An example of an unelastic application is a database whose load fluctuates and costs its users much of any delay in its responses. An example of elastic application is the processing of large volumes of gene material that may require thousands of hours of processing but are not affected by fluctuations in the processing power it receives, as long as it takes as long as necessary.\par
An appropriate tool is needed to enable the data center to prioritize some applications to their respective millimeters of computing power. The Linux cgroup system is such a tool that can impose quantitative restrictions and share computing resources.\par
The purpose of the exercise is to create programs that, using the cgroup system, can provide computing power, configured in milliseconds of a processor as above.\par
\b\par
Daemon cgmond\b0\par
The utility is provided by cgmond, a program (daemon in the sense of unix) that launches and monitors applications, as well as imposes the least secured millimeters of processing power as given at startup.\par
Cgmond does not interpret the values \u8203?\u8203?for the least secured millimeters of each application, nor does it apply cgroup settings. Instead, it calls two externally executable programs, cgmon-policy and cgmon-limit, respectively.\par
Whenever an application is created or terminated, cgmond executes the cgmon-policy by giving it all the applications with their millimeter settings. Cgmon-policy generates the settings for the cgroup system to be implemented. Next, cgmon-limit is called to apply the settings generated by cgmon-policy.\par
If you are prompted to start an application with millimeters more than the system can guarantee then it warns and requires confirmation.\par
\b To Do:\b0\par
It is required to write appropriate cgmon-policy and gmon-limit programs and find appropriate applications to satisfy and demonstrate the following:\par
1. To comply with the specifications given in the respective sections so that they can be used by cgmond.\par
2. After the cgmon-limit application of the cgroup settings produced by the cgmon-policy, the minimum milliseconds of each application as declared at startup must be ensured.\par
3. The cgmon-policy should be appropriately rated for its entry so that cgmond will prevent application launching if the guaranteed millimeters of any application are to be compromised.\par
4. If there are flexible/elastic and inelastic applications under surveillance ensure that all node processors are used and no one is left idle.\par
\b Executable cgmon-policy\par
\b0 In summary, the executable cgmon-policy is called to convert the measure of the minimum secured millisecond usage of a processor, the size of the user transaction, to cpu.shares, the size that the cgroup system configures for processing power into applications.\par
The program receives the form input:\par
 policy: <application name>: cpu: <value>\par
 ...\par
Where each line corresponds to the application with the application name. The value is a positive integer corresponding to the millimeters of a processor we want to ensure for the application.\par
Each line ends with a '\\ n' (ascii 0xa) character. Policy and cpu are stable and appear as they are.\par
At its output the program produces corresponding lines:\par
 score: <float>\par
 set_limit: <application name>: cpu.shares: <value>\par
 ...\par
The score, set_limit, cpu.shares are constant and appear as they are.\par
In the first line of the output, the float is a decimal value that if positive indicates that the minimum usage limits are assured for all applications, and if negative then the limits cannot be met.\par
The following lines each refer to the corresponding application name. The value is a positive decimal integer and corresponds to the cpu.shares setting of the corresponding cgroup of the application.\par
\b Executable cgmon-limit\b0\par
In summary, the executable cgmon-limit undertakes to apply the settings generated by the cgmon-policy, as well as to maintain the display of applications in cgroup hierarchies ordered by cgmond.\par
The executable accepts at the input lines one of the following types:\par
Create a cgroup for a new application:\par
 create: <monitor>: cpu: <application name>\par
Remove the cgroup of an application that has terminated\par
 remove: <monitor>: cpu: <application name>\par
Register a process in the cgroup of an application:\par
 add: <monitor>: cpu: <application name>: <process id>\par
Set the cpu.shares value for the cgroup of an application: \par
 set_limit: <monitor>: cpu: <application name>: cpu.shares: <value>\par
The monitor identifier corresponds to the cgmond which contains all the cgroups of the applications. This isolates the app namespace from the rest of the system to avoid conflicts (eg someone trying to name an application with a cgroup name already in the system).\par
\par
\b Cgroup / cpu subsystem\b0\par
The cpu subsystem starts by assigning all the computational power of all processors to the top of the hierarchy. Each cpu cgroup has a cpu.shares setting. Each level sums up all the cpu.shares values \u8203?\u8203?of the cgroups belonging to that level. The total computing power available at this level is divided into equal and equivalent segments. Each cgroup receives as many segments as its cpu.shares value.\par
\b Access to virtual machine\par
\b0 For the purpose of exercise you are offered a virtual machine. To use it, follow these steps:\par
1. Visit {{\field{\*\fldinst{HYPERLINK https://okeanos.grnet.gr }}{\fldrslt{https://okeanos.grnet.gr\ul0\cf0}}}}\f0\fs24  and use your academic account to sign in. You will be prompted to select your institution before entering your password.\par
2. Visit the dashboard in the upper right corner.\par
3. Tap on the tab projects\par
4. Select join at oslab2016.cslab.ntua.gr\par
5. Wait for approval from laboratory staff (they will confirm your details). You will receive a notification when your registration is complete.\par
6. Tap Cyclades in the zone at the top of the page\par
7. Choose to create a new virtual machine\par
8. Select Debian base image. It should be noted that IPV4 creation, in the corresponding step, is necessary in order to support the classic ways of accessing the virtual machine. It is also advisable to create a ssh key in the corresponding step, otherwise enter the password after the creation.\par
9. Log in as root user with ssh.\par
10. Perform the steps in Appendix A manually or by performing them as scripts. Inside them look at the address where you will find the cgmond code.\par
\par
\par
}
 